---
title: "AIMS and SBP data interpolation and benthic cover estimation for Atlantis initial conditions"
author: "Alberto Rovellini (on Shane Richard's script)"
date: "July 18, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary

Read in pre-processed data and calculate cover values for initial conditions. This where the interpolation between AIMS benthic monitoring data (AIMS) and Seabed Biodiversity Project (SBP) data is carried out.

# Read in data

```{r readData, message=FALSE}
rm(list = ls())

library(ggplot2)
library(dplyr)
library(tidyr)
library(ggtern)
library(reshape2)
library(ggforce)

# library(maptools)
# library(ggmap)
# library(sp)
# library(raster)
# library(rgdal)
# library(rgeos)
# library(maptools)
# library(stringr)
# library(mgcv)

# read in data
# firts seabed


df.SBP <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Model development files/prior_HP documents/Data/Benthic/dataSites.csv", stringsAsFactors = FALSE)

# then AIMS

df.AIMS <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/AIMS_benthic_monitoring/dataAIMS.csv", stringsAsFactors = FALSE)

# read the correct dataBox (generated by the new file Analysis1_Shapefile_AIMS.rmd)

df.Box <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/AIMS_benthic_monitoring/dataBoxes.csv", stringsAsFactors = FALSE)

```

```{r plotOnReef}
ggplot(data = df.SBP, aes(x = LONGITUDE, y = LATITUDE, color = on.reef)) +
  geom_point(size = 0.5) +
  geom_point(data = df.AIMS, aes(x = LONGITUDE, y = LATITUDE, color = on.reef),
             size = 0.5)+
  scale_colour_manual(values=c("grey75", "red")) +
  scale_x_continuous(breaks=c(140,143,146,149,152,155)) + 
  labs(fill = "On reef") +
  xlab("Longitude") + ylab("Latitude")
```

SBP dataset covers the GBR area much more homgeneously, wherease AIMS data is sparse on the reefs. However, reef data seems now to cover more or less homogenously the N-S model domain. Therefore, although it will not be enough to estimate cover of benthic organisms on coral reefs for each box, at least it should allow to come up with estimates for the Northern, central and Southern sectors of the GBR.

```{r}

# first deal with SBP

GroupsSite <- names(df.SBP)[c(8:16,19:44)] # select relevant column names

GroupsGBR  <- c( # categorise SBP site variables in terms of the GBR model variables
  "Soft",          "Soft",       "Flat", 
  "Flat",          "Flat",       "Reef", 
  "Reef",          "Reef",       "Reef",
  "CoralSoft",     "CoralSoft",  "CoralSoft",
  "CoralSoft",     "CoralSoft",  "CoralSoft",
  "CoralSoft",     "CoralSoft",  "CoralSoft",
  "Sponges",       "Sponges",    "Sponges",
  "CoralBrain",    "CoralBrain", "CoralBrain",
  "CoralBrain",    "AlgaeTurf",  "AlgaeTurf",
  "AlgaeCC",       "Macroalgae", "Seagrass",
  "OtherBivalves", NA,           "Benthic_Carniv", 
  NA,              NA)

df.Groups <- data.frame(GroupsSite, GroupsGBR, stringsAsFactors = FALSE)
glimpse(df.Groups)
```

```{r}

# It is probably best to rearrange the SBP data altogether and try and merge the datasets now, as this point they are treated equally. Loops will need to be reworked accordingly. We will need 3 vectors for reef cover

df.short.SBP <- df.SBP %>% dplyr::select(
  SITE_ID, LATITUDE, LONGITUDE, AlcyonSparse:TubePolychaeteBeds, soft:boxid
) %>% mutate (
  AlgaeCC = (Halimeda)/100,
  AlgaeTurf = (Flora + Algae)/100,
  CoralBrain = ((HardCoralSparse + HardCoralMedium + HardCoralDense + LiveReefCorals)/3)/100,
  CoralBranch = ((HardCoralSparse + HardCoralMedium + HardCoralDense + LiveReefCorals)/3)/100,
  CoralSheet = ((HardCoralSparse + HardCoralMedium + HardCoralDense + LiveReefCorals)/3)/100,
  CoralSoft = (AlcyonSparse + AlcyonMedium + AlcyonDense + WhipSparse + WhipMedium + WhipDense + GorgonSparse + GorgonMedium + GorgonDense)/100,
  Sponges = (SpongeSparse + SpongeMedium + SpongeDense)/100,
  Macroalgae = (Caulerpa)/100,
  seagrass = (Seagrass)/100,
  OtherBivalves = (BivalveShellBeds)/100,
  Reef = reef,
  Flat = flat,
  Soft = soft,
  TotalHabitat = total.cover
) %>% dplyr::select(
  SITE_ID:LONGITUDE, AlgaeCC:TotalHabitat, boxid, on.reef
) %>% mutate (
  Live = AlgaeCC + AlgaeTurf + CoralBrain + CoralBranch + CoralSheet + CoralSoft + Sponges + Macroalgae + OtherBivalves
)

# these need to become proportion covers. 

# now need to make the two frames consistent in terms of: column names, columns order and class

# Let's stick with SBP for format as it has more categories

df.short.AIMS <- df.AIMS %>% mutate (
  SITE_ID = paste(REEF_NAME, SITE_NO, YEAR, sep = "_")
)

df.short.AIMS$Seagrass <- rep(0, dim(df.short.AIMS)[1]) # making the assumption that seagrass cover is 0 on reef
df.short.AIMS$OtherBivalves <- rep(0, dim(df.short.AIMS)[1]) # same. The reason for this is that if these were present (in non negligible quantities) they would have been recorded as categories in the AIMS data. We still have to introduce them as they are present (expectedly) in the seabed data
df.short.AIMS$Mud <- rep(0, dim(df.short.AIMS)[1])

df.AIMS.final <- df.short.AIMS %>% dplyr::select (
  SITE_ID, LATITUDE, LONGITUDE, AlgaeCC:CoralSoft, Macroalgae, OtherBivalves, Seagrass, Sponges, Reef, Flat, Mud, TotalHabitat, boxid, on.reef
)

df.SBP.final <- df.short.SBP %>% dplyr::select (
  SITE_ID:CoralSoft, Macroalgae, OtherBivalves, seagrass, Sponges, Reef:on.reef
)

# correct seagrass to Seagrass and make sure that they all have the same names

names(df.SBP.final) <- names(df.AIMS.final)

# now concatenate the two datasets

all.data <- rbind(df.AIMS.final, df.SBP.final)

```

Plot all data points and the Atlantis grid for report.

```{r, fig.width = 7.5, fig.height = 9}

df.map <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/df_map.csv")

all.data.plot <- all.data

all.data.plot$Set <- c(rep("AIMS", 281), rep("SBP", (nrow(all.data.plot)-281)))

all.data.plot <- ggplot(data = all.data.plot, aes(x = LONGITUDE, y = LATITUDE, color = Set))+
  geom_polygon(data = df.map,
    aes(x = x, y = y, group = boxid), colour = "grey10", fill = NA, size = 0.25)+
  geom_point(size = 1.0, alpha = 0.4) +
  scale_color_manual(values = c("firebrick", "deepskyblue"))+
  scale_y_continuous(breaks = seq(-10, -25, -5))+
  scale_x_continuous(breaks=c(140,143,146,149,152,155)) + 
  labs(fill = "On reef") +
  xlab("Longitude") + ylab("Latitude")+
  theme_bw()

# ggsave("C:/Users/arove/Documents/Projects/Chapter3/textForThesis/pics/all_data_plot.png", all.data.plot, height = 8, width = 7, dpi = 600)

```

Follows:

1. Box-wise calculation of benthic cover on non-reef sites. This uses the SBP data only, as all AIMS data is on reef.
2. Region-wise calculation of benthic cover on coral reefs. This uses all AIMS data and a small subset of SBP data that was found to be on hard substrate (mostly up north).

```{r}

# Non-reef first

GBRgroups <- names(all.data)[-c(1:3,17:19)]

Cover.noreef <- matrix(data = 0, nrow = dim(df.Box)[1], ncol = length(GBRgroups)) 
colnames(Cover.noreef) <- GBRgroups

cover.only <- all.data[,c(4:16)]

# this will include ONLY SBP sites as AIMS sites are ALL on reef

for (i in 1:length(GBRgroups)) { # i is the column of Site data
  
  for (k in 1:dim(all.data)[1]) { # each site / row
    # check that site is not a reef site 
    if (!all.data$on.reef[k]) {
      b1 <- all.data$boxid[k] # boxid that site is in
      if (df.Box$is.interior[b1+1]) { 
        Cover.noreef[b1+1,i] <- Cover.noreef[b1+1,i] +
          cover.only[k,i]/(df.Box$sites[b1+1] - df.Box$sites.reef[b1+1]) 
      }
      
    } 
  }
}

# the original of the below will refuse to work (not apparent why) so come up with cheat column for the moment

df.Box$Cheat <- rep(0, dim(df.Box)[1])
for (i in 1:dim(df.Box)[1]) {
  if(is.na(df.Box$boxid[i] == df.Box$boxid.ref[i])) {
  df.Box$Cheat[i] <- 1
  }
}

# copy values from neighbouring box for boxes without sites
for (i in 1:dim(df.Box)[1]) { # for each box
  if (df.Box$Cheat[i] == 0) {
    if (df.Box$is.interior[i] & !(df.Box$boxid[i] == df.Box$boxid.ref[i])) { 
      # need to copy neighbour values for all variables
      Cover.noreef[df.Box$boxid[i]+1, ] <- Cover.noreef[df.Box$boxid.ref[i]+1, ] 
    }
  }
}


# Reef now. We want to isolate the reef sites almost and split them into 3, have a list.

# subset the frame here

all.reef <- all.data %>% filter(on.reef == TRUE)

# add column that places reefs in N, C, S segments

range.lat <- c(max(all.reef$LATITUDE), min(all.reef$LATITUDE)) # get latitudinal range
seq.lat <- seq(from = range.lat[1], range.lat[2], by = ((range.lat[2] - range.lat[1])/(4 - 1))) # split into 3 regions

all.reef$Region <- rep(NA, dim(all.reef)[1])

for (i in 1:dim(all.reef)[1]) {
  if (all.reef$LATITUDE[i] >= seq.lat[2]) {
    all.reef$Region[i] <- "NORTH"
  } else if (all.reef$LATITUDE[i] < seq.lat[2] &  all.reef$LATITUDE[i] >= seq.lat[3]) {
    all.reef$Region[i] <- "CENTER"
  } else if (all.reef$LATITUDE[i] < seq.lat[3]) {
    all.reef$Region[i] <- "SOUTH"
  }
}

# reorder levels N - C - S

all.reef$Region <- factor(all.reef$Region, levels = c("NORTH", "CENTER", "SOUTH"))

# split into the three Regions

regions <- split(all.reef, all.reef$Region) # N has the least sites (44), C and S are equal (130, 136) 

# loop over regions

reef.vectors <- vector(mode = "list", length = length(regions))

for (j in 1:length(regions)) {
  
  reg <- regions[[j]]
  
  Cover.reef <- rep(0, length(GBRgroups))
  reef.sites <- sum(reg$on.reef)
  
  reg.cover.only <- reg[,c(4:16)]
  
  for (i in 1:length(GBRgroups)) {
    # i is the column of Site data
    for (k in 1:dim(reg.cover.only)[1]) {
      # check that site is a reef site 
      b1 <- reg$boxid[k] # boxid that site is in
      if (!is.na(reg.cover.only[k,i]) & df.Box$is.interior[b1+1]) {
        # convert percentage to fraction
        Cover.reef[i] <- Cover.reef[i] + reg.cover.only[k,i]/reef.sites
      }
    }
  }
  reef.vectors[[j]] <- Cover.reef
}

# Divide the dataframe of boxes into 3 according to the corresponding latitudinal gradient. Use the box midpoint

df.Box$Region <- rep(NA, dim(df.Box)[1])

for (i in 1:dim(df.Box)[1]) {
  if (df.Box$y.in[i] >= seq.lat[2]) {
    df.Box$Region[i] <- "NORTH"
  } else if (df.Box$y.in[i] < seq.lat[2] &  df.Box$y.in[i] >= seq.lat[3]) {
    df.Box$Region[i] <- "CENTER"
  } else if (df.Box$y.in[i] < seq.lat[3]) {
    df.Box$Region[i] <- "SOUTH"
  }
}

# reorder levels

df.Box$Region <- factor(df.Box$Region, levels = c("NORTH", "CENTER", "SOUTH"))

# split according to region

box.regions <- split(df.Box, df.Box$Region)

# now loop to apply to each. start from one

cover.by.region <- vector(mode = "list", length = length(box.regions))

for (k in 1:length(box.regions)) {
  
  reg.box <- box.regions[[k]]
  
  Cover <- matrix(data = 0, nrow = dim(reg.box)[1], ncol = length(GBRgroups))
  colnames(Cover) <- GBRgroups
  
  for (i in 1:length(GBRgroups)) { # cover type
    for (j in 1:dim(reg.box)[1]) { # boxid
      b1 <- reg.box$boxid[j] # make sure you point to the correct box in the Cover.noreef data frame, which is longer than the indeces of these loops
      if (reg.box$is.interior[j]) { 
        # only consider interior boxes. This means non boundary boxes
        Cover[j,i] <- (1.0 - reg.box$frac.reef[j]) * Cover.noreef[b1+1,i] + 
          reg.box$frac.reef[j] * reef.vectors[[k]][i]
      }
    }
  }
  
  cover.by.region[[k]] <- data.frame(reg.box$boxid, Cover)
  
}

est.cover <- do.call("rbind", cover.by.region) # stitch the three dataframes together into a dataframe of the estimated percent cover inside a box

# re-order the boxes as it is not 0:107 now

est.cover <- est.cover[order(est.cover$reg.box.boxid),]

names(est.cover) <- c("boxid", names(est.cover)[-1])

write.csv(est.cover, file = "C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/AIMS_benthic_monitoring/GRBCoverParamEstAIMS_and_SBP/estCoverAIMS_andSBP.csv", row.names=FALSE)
```

The below compares this new estimate of the live benthic cover with the old one that included only the seabed data

```{r}

df.AIMS.SBP <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/AIMS_benthic_monitoring/GRBCoverParamEstAIMS_and_SBP/estCoverAIMS_andSBP.csv")

df.SBP <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Model development files/prior_HP documents/Data/init/estCover.csv")

live.AIMS.SBP <- df.AIMS.SBP %>% dplyr::select(
  AlgaeCC:Sponges
) %>% rowSums()

live.SBP <- df.SBP %>% dplyr::select(
  AlgaeCC:Sponges
) %>% rowSums()

compare <- data.frame(live.AIMS.SBP, live.SBP, perc.change = ((live.AIMS.SBP - live.SBP)/live.SBP)*100)
compare$perc.change[is.infinite(compare$perc.change)] <- NA
compare$perc.change[is.nan(compare$perc.change)] <- NA


summary(compare)
mean(compare$perc.change, na.rm = TRUE)
max(compare$perc.change, na.rm = TRUE)
min(compare$perc.change, na.rm = TRUE)


```

Some boxes undergo minor changes in their cover, especially those with a domiannce of deep, soft bottom. Boxes with a high reef proportion, however, present major differences from the live cover estimated with the seabed data. This is not surprising as the seabed data specifically avoids reefs, whereas the AIMS data targets them. All in all, it is reasonable to use mostly the AIMS data for estimation of what is on shallow coral reefs, and the seabed data for the estimation of what is in inter-reefal habitats and deeper water. Although still too sparse to cover every box (or the majority of boxes) like the seabed dataset did, the AIMS data is geographically wide enough to allow to come up with three vectors for benthic cover: one for the Northern reefs, one for the central region of the GBR, and one for the Southern reefs. This was calculated by splitting the sampled latitude into thirds, rather than relying on existing subdivisions of the GBR that may be more widely accepted. This constituded the attempt to keep the model data-driven.

Plot final values of cover for report

```{r}

df.map <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/df_map.csv")

n.times <- unlist(lapply(split(df.map, df.map$boxid), function(x) nrow(x)), use.names = F) # number of times each box is replicated in df.map

stretched.cover <- est.cover[rep(seq_len(nrow(est.cover)), n.times),] # repeat each row of est.cover depending on the number of box iterations

stretched.cover <- stretched.cover %>% dplyr::mutate(
  Corals = CoralBrain + CoralBranch + CoralSheet
) %>% dplyr::select(
  boxid:AlgaeTurf, CoralSoft:Sponges, Corals
)

# must turn to NA all the cover values in boundary boxes

boundary.boxes <- c(0, 2, 20, 34, 43, 57, 66, 80, 102)

stretched.cover[stretched.cover$boxid %in% boundary.boxes,] <- rep(NA, ncol(stretched.cover))

# remove box column

stretched.cover <- stretched.cover[,-1]

# drop useless columns from the map dataframe

df.map <- df.map %>% dplyr::select(
  boxid:y
)

cover.boxes <- cbind(df.map, stretched.cover)

cover.boxes <- cover.boxes %>% dplyr::select(
  boxid:Corals
)

# now arrange in long format for ggplot

cover.long <- melt(cover.boxes, id.vars = list("boxid", "x", "y"), variable.name = "Group", value.name = "Cover")

# reorder levels

cover.long$Group <- factor(cover.long$Group, levels = c("Corals", "Sponges", "Macroalgae", "AlgaeTurf", "AlgaeCC", "Seagrass", "CoralSoft", "OtherBivalves"))

```

```{r, fig.width = 9, fig.height = 9}

n_pages <- 2

for (i in 1:n_pages) {
  
  cover.plot <- ggplot(data = cover.long, aes(x = x, y = y)) +
    geom_polygon(aes(fill = Cover, group = boxid), color = "black", size = 0.25) +
    facet_wrap( ~ habitat, ncol = 3) +
    scale_fill_gradient(low = "blue", high = "red", na.value = "white") +
    scale_x_continuous(breaks=c(140,143,146,149,152,155)) + 
    labs(fill = "Cover (0-1)") +
    xlab("Longitude") + ylab("Latitude") +
    ggplot2::theme_bw()+
    facet_wrap_paginate(~ Group, ncol = 2, nrow = 2, scales = "free", page = i)
  
  ggsave(paste("C:/Users/arove/Documents/Projects/Chapter3/textForThesis/pics/", i, "cover_Atlantis_GBR.png"), cover.plot, width = 9, height = 10, dpi = 600)
  
}

```

Plot the model domain and the depth of the boxes, also attribute NA to the boundary boxes and plot those as grey or white.

```{r}

df.map <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/df_map.csv")

df.boxes <- read.csv("C:/Users/arove/Documents/Projects/Chapter3/Atlantis_resources/Data/AIMS_benthic_monitoring/dataBoxes.csv")

df.boxes <- df.boxes %>% dplyr::select(
  boxid, z, x.in, y.in
)

# must drop gradient and do categories

depths <- c(0, 5, 10, 20, 50, 100, 200, 3000)

df.boxes$Depth <- rep(NA, dim(df.boxes)[1])

df.boxes$z <- -df.boxes$z

for (i in 1:dim(df.boxes[1])) {
  df.boxes$Depth[i] <- paste(depths[which(depths <= df.boxes$z[i])][length(which(depths <= df.boxes$z[i]))],
                             "-", 
                             depths[which(depths > df.boxes$z[i])][1],
                             sep = "")
}

n.times <- unlist(lapply(split(df.map, df.map$boxid), function(x) nrow(x)), use.names = F) # number of times each box is replicated in df.map

stretched.boxes <- df.boxes[rep(seq_len(nrow(df.boxes)), n.times),] # repeat each row of df.boxes depending on the number of box iterations

# must turn to NA all the cover values in boundary boxes

boundary.boxes <- c(0, 2, 20, 34, 43, 57, 66, 80, 102)

stretched.boxes[stretched.boxes$boxid %in% boundary.boxes,] <- rep(NA, ncol(stretched.boxes))

# remove boxid column

stretched.boxes <- stretched.boxes[,-1]

model.domain <- cbind(df.map, stretched.boxes)

# reorder factors 

model.domain$Depth <- factor(model.domain$Depth, levels = c("0-5", "5-10", "10-20", "20-50", "50-100", "100-200", "200-3000"))

```

Plot

```{r}

depth.plot <- ggplot(data = model.domain, aes(x = x, y = y)) +
  geom_polygon(aes(fill = Depth, group = boxid), color = "black", size = 0.25) +
  #geom_polygon(data = oz, aes(x = long, y = lat))+
  scale_fill_manual(values = c("seashell1", "lightsteelblue1", "steelblue1", "royalblue", "blue", "navyblue", "white"))+
  # scale_x_continuous(breaks = c(140,143,146,149,152,155), limits = c(142, 155)) +
  # scale_y_continuous(limits = c(-26, -10))+
  labs(fill = "Depth") +
  xlab("Longitude") + ylab("Latitude") +
  ggplot2::theme_bw()

depth.plot

ggsave("C:/Users/arove/Documents/Projects/Chapter3/textForThesis/pics/depth_plot.pdf", depth.plot, width = 8, height = 9, dpi = 600)

```

